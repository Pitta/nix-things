#+TITLE: Nix Command Reference
#+AUTHOR: github.com/Pitta

A reference to ~nix~ commands found to be helpful in day to day use.

* Package Management

Coming from package managers like ~brew~, ~port~, ~apt~, etc., ~nix~ can /seem/ daunting/impenetrable. These section should help demystify how to use ~nix~ as a drop in replacement for how most folks approach using the aforementioned tools.

- [[#-searching-for-packages][Searching for Packages]]
- [[#-imperitive-package-management][Imperitive Package Management]]
  - how most users manage packages, typically by invoking an install command with the package manager of choice.
- [[#-declaritive-package-management][Declaritive Package Management]]
  - A more portable, version controll-able approach that declares the desired end state. Great for using the same configuration across multiple machines.
- [[#-temporary-packages][Temporary Packages]]
  - Excellent for testing new versions of packages, or entirely new tools, without comitting to system level changes that could impact other parts of the system.

** üîç Searching for Pacakges

#+begin_quote
/Question: I want to install pacakges, but I'm not sure what is avalible/
#+end_quote

Search for packages via:
- The web UI @ https://search.nixos.org/
- Using the cli:
  #+begin_src bash
  nix-env -qaP 'some_package' 
  #+end_src

  - ~-q~: Stands for "query". Used to query the Nix store for /installed/ pacakges
  - ~-a~: Stands for "avalible". Used to search for /avalible packages/ to be installed
  - ~-P~: Includes the attribute path of the package. This result is often used with the ~-A~ flag during installs to more precisely target the desired package.

** ü™õ Imperative Package Management

#+begin_quote
/Question: I'm used to tools like ~brew~ - how do I use ~nix~ in a similar way?
#+end_quote

If your workflow has involved...
- ~brew install some_package~
- ~port install some_package~
- ~api-get install some_package~

...and are making the move to ~nix~, then you are in the right place! ~nix~ can be used as a drop in replacement for these tools on most linux/unix based systems.

*** Install a package

Once the desired package has been identified, use ~nix-env~ to install the package globally...

#+begin_src bash
  nix-env -i some_package
#+end_src

- ~-i~: short flag for ~--install~.
  - Takes multiple arguements in a space-seperated list.
  - By default, ~nix-env -i~ will do a lookup of the argument given against ~nixpkgs~, similarly to going to https://search.nixos.org/, searching, and using the top result.
- ~-A~: short for ~--attr~ across many ~nix~ commands.
  - Instead of relying on the lookup, which could be slow at times, one could add ~-A~ along with the /exact/ package name to skip the lookup completely. This requires the name given to be exact, and can allow for installing a specific version of the target package.
  - Can be combined with other flags i.e. ~-iA~

*** Uninstalling a package

SoonTM

** üìù Declaritive Pacakge Management

To be detailed later.

There are a few ways to approach this, including using ~flakes~ or helper packages installed imperatively like ~home-manager~

** üóëÔ∏è Temporary Packages

Want to test a new tool or utility without making any permanent changes to your system? Lets test this with a couple of system info tools.

Using ~nix-shell~, we can drop into a new temporary shell, adding any number of packages to this temporary shell with the ~-p~ flag 
#+begin_src bash
  nix-shell -p neofetch
#+end_src

That's it! You can add as many packages as you like to the ~-p~ flag, seperateing each package with a single space. Upon ~exit~ of the shell, all the "installed" packages are removed from your envrionment.

*** Validate

Once in the temporary shell:

1. Run ~which neofetch~ to see where the binary sits on your system
   - Note the location is in a directory like ~/nix/store/somelonghash/bin~
2. Run ~neofetch~ to run the application itself
3. Run ~exit~ to leave the temporary shell
4. Try running ~neofetch~ again
   - It should throw an error saying "command not found"
